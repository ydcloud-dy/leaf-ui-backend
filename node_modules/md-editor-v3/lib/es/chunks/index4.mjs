import { defineComponent as z, inject as q, ref as $, watch as J, onMounted as K, createVNode as N, reactive as X, shallowRef as G, provide as V, computed as Y, onBeforeUnmount as Z, Fragment as ee } from "vue";
import { p as O } from "./config.mjs";
import { b as w, j, G as U, k as te, S as le } from "./event-bus.mjs";
import { a as oe } from "./index5.mjs";
import { createSmoothScroll as ne, debounce as ie } from "@vavt/util";
const ce = `.${O}-preview > [data-line]`, D = (e, l) => +getComputedStyle(e).getPropertyValue(l).replace("px", ""), ve = (e, l) => {
  const C = ie(() => {
    e.removeEventListener("scroll", n), e.addEventListener("scroll", n), l.removeEventListener("scroll", n), l.addEventListener("scroll", n);
  }, 50), n = (E) => {
    const m = e.clientHeight, b = l.clientHeight, f = e.scrollHeight, s = l.scrollHeight, r = (f - m) / (s - b);
    E.target === e ? (l.removeEventListener("scroll", n), l.scrollTo({
      top: e.scrollTop / r
      // behavior: 'smooth'
    }), C()) : (e.removeEventListener("scroll", n), e.scrollTo({
      top: l.scrollTop * r
      // behavior: 'smooth'
    }), C());
  };
  return [
    () => {
      C().finally(() => {
        e.dispatchEvent(new Event("scroll"));
      });
    },
    () => {
      e.removeEventListener("scroll", n), l.removeEventListener("scroll", n);
    }
  ];
}, ge = (e, l, C) => {
  const { view: n } = C, E = ne(), m = (c) => n.lineBlockAt(n.state.doc.line(c + 1).from).top, b = (c) => n.lineBlockAt(n.state.doc.line(c + 1).from).bottom;
  let f = [], s = [], r = [];
  const L = () => {
    f = [], s = Array.from(
      l.querySelectorAll(ce)
    ), r = s.map((o) => Number(o.dataset.line));
    const c = [...r], { lines: g } = n.state.doc;
    let H = c.shift() || 0, t = c.shift() || g;
    for (let o = 0; o < g; o++)
      o === t && (H = o, t = c.shift() || g), f.push({
        start: H,
        end: t - 1
      });
  }, R = (c, g) => {
    let H = 1;
    for (let t = s.length - 1; t - 1 >= 0; t--) {
      const o = s[t], a = s[t - 1];
      if (o.offsetTop + o.offsetHeight > g && a.offsetTop < g) {
        H = Number(a.dataset.line);
        break;
      }
    }
    for (let t = f.length - 1; t >= 0; t--) {
      const o = b(f[t].end), a = m(f[t].start);
      if (o > c && a <= c) {
        H = H < f[t].start ? H : f[t].start;
        break;
      }
    }
    return H;
  };
  let x = 0, B = 0;
  const _ = () => {
    if (B !== 0)
      return !1;
    x++;
    const { scrollDOM: c, contentHeight: g } = n;
    let H = D(l, "padding-top");
    const t = n.lineBlockAtHeight(c.scrollTop), { number: o } = n.state.doc.lineAt(t.from), a = f[o - 1];
    if (!a)
      return !1;
    let u = 1;
    const p = l.querySelector(`[data-line="${a.start}"]`) || l.firstElementChild?.firstElementChild, d = l.querySelector(`[data-line="${a.end + 1}"]`) || l.lastElementChild?.lastElementChild, i = c.scrollHeight - c.clientHeight, k = l.scrollHeight - l.clientHeight;
    let h = m(a.start), v = b(a.end), S = p.offsetTop, y = d.offsetTop - S;
    h === 0 && (S = 0, p === d ? (H = 0, v = g - c.offsetHeight, y = k) : y = d.offsetTop), u = (c.scrollTop - h) / (v - h);
    const A = d == l.lastElementChild?.lastElementChild ? d.offsetTop + d.clientHeight : d.offsetTop;
    if (v >= i || A > k) {
      const I = R(i, k);
      h = m(I), u = (c.scrollTop - h) / (i - h);
      const P = l.querySelector(`[data-line="${I}"]`);
      h > 0 && P && (S = P.offsetTop), y = k - S + D(l, "padding-top");
    }
    const T = S - H + y * u;
    E(l, T, () => {
      x--;
    });
  }, F = () => {
    if (x !== 0)
      return;
    B++;
    const { scrollDOM: c } = n, g = l.scrollTop, H = l.scrollHeight, t = c.scrollHeight - c.clientHeight, o = l.scrollHeight - l.clientHeight;
    let a = l.firstElementChild?.firstElementChild, u = l.firstElementChild?.lastElementChild;
    if (r.length > 0) {
      let A = Math.ceil(
        r[r.length - 1] * (g / H)
      ), T = r.findLastIndex((I) => I <= A);
      T = T === -1 ? 0 : T, A = r[T];
      for (let I = T; I >= 0 && I < r.length; )
        if (s[I].offsetTop > g) {
          if (I - 1 >= 0) {
            I--;
            continue;
          }
          A = -1, T = I;
          break;
        } else {
          if (I + 1 < r.length && s[I + 1].offsetTop < g) {
            I++;
            continue;
          }
          A = r[I], T = I;
          break;
        }
      switch (T) {
        case -1: {
          a = l.firstElementChild?.firstElementChild, u = s[T];
          break;
        }
        case r.length - 1: {
          a = s[T], u = l.firstElementChild?.lastElementChild;
          break;
        }
        default:
          a = s[T], u = s[T + 1 === s.length ? T : T + 1];
      }
    }
    let p = a === l.firstElementChild?.firstElementChild ? 0 : a.offsetTop - D(a, "margin-top"), d = u.offsetTop, i = 0;
    const { start: k, end: h } = f[Number(a.dataset.line || 0)];
    let v = m(k);
    const S = m(
      h + 1 === n.state.doc.lines ? h : h + 1
    );
    let y = 0;
    if (S > t || u.offsetTop + u.offsetHeight > o) {
      const A = R(t, o), T = l.querySelector(`[data-line="${A}"]`);
      p = T ? T.offsetTop - D(T, "margin-top") : p, v = m(A), i = (g - p) / (o - p), y = t - v;
    } else a === l.firstElementChild?.firstElementChild ? (a === u && (d = u.offsetTop + u.offsetHeight + +getComputedStyle(u).marginBottom.replace("px", "")), y = S, i = Math.max(g / d, 0)) : (i = Math.max(
      (g - p) / (d - p),
      0
    ), y = S - v);
    E(e, v + y * i, () => {
      B--;
    });
  }, M = (c) => {
    const { scrollDOM: g, contentHeight: H } = n, t = g.clientHeight;
    if (H <= t || l.firstElementChild.clientHeight <= l.clientHeight || n.state.doc.lines <= f[f.length - 1]?.end)
      return !1;
    c.target === e ? _() : F();
  };
  return [
    () => {
      L(), e.addEventListener("scroll", M), l.addEventListener("scroll", M), e.dispatchEvent(new Event("scroll"));
    },
    () => {
      e.removeEventListener("scroll", M), l.removeEventListener("scroll", M);
    }
  ];
}, se = {
  tocItem: {
    type: Object,
    default: () => ({})
  },
  mdHeadingId: {
    type: Function,
    default: () => {
    }
  },
  onActive: {
    type: Function,
    default: () => {
    }
  },
  onClick: {
    type: Function,
    default: () => {
    }
  },
  scrollElementOffsetTop: {
    type: Number,
    default: 0
  }
}, Q = /* @__PURE__ */ z({
  props: se,
  setup(e) {
    const l = q("scrollElementRef"), C = q("roorNodeRef"), n = $();
    J(() => e.tocItem.active, (m) => {
      m && e.onActive(e.tocItem, n.value);
    }), K(() => {
      e.tocItem.active && e.onActive(e.tocItem, n.value);
    });
    const E = (m) => {
      if (m.stopPropagation(), e.onClick(m, e.tocItem), m.defaultPrevented)
        return;
      const b = e.mdHeadingId({
        text: e.tocItem.text,
        level: e.tocItem.level,
        index: e.tocItem.index,
        currentToken: e.tocItem.currentToken,
        nextToken: e.tocItem.nextToken
      }), f = C.value.getElementById(b), s = l.value;
      if (f && s) {
        let r = f.offsetParent, L = f.offsetTop;
        if (s.contains(r))
          for (; r && s != r; )
            L += r?.offsetTop, r = r?.offsetParent;
        const R = f.previousElementSibling;
        let x = 0;
        R || (x = D(f, "margin-top")), s?.scrollTo({
          top: L - e.scrollElementOffsetTop - x,
          behavior: "smooth"
        });
      }
    };
    return () => N("div", {
      ref: n,
      class: [`${O}-catalog-link`, e.tocItem.active && `${O}-catalog-active`],
      onClick: E
    }, [N("span", {
      title: e.tocItem.text
    }, [e.tocItem.text]), e.tocItem.children && e.tocItem.children.length > 0 && N("div", {
      class: `${O}-catalog-wrapper`
    }, [e.tocItem.children.map((m) => N(Q, {
      mdHeadingId: e.mdHeadingId,
      key: `${e.tocItem.text}-link-${m.level}-${m.text}`,
      tocItem: m,
      onActive: e.onActive,
      onClick: e.onClick,
      scrollElementOffsetTop: e.scrollElementOffsetTop
    }, null))])]);
  }
}), re = {
  /**
   * 编辑器的Id，务必与需要绑定的编辑器Id相同
   */
  editorId: {
    type: String,
    default: void 0
  },
  class: {
    type: String,
    default: ""
  },
  mdHeadingId: {
    type: Function,
    default: ({
      text: e
    }) => e
  },
  /**
   * 指定滚动的容器，选择器需带上对应的符号，默认预览框
   * 元素必须定位！！！！！！
   *
   * 默认：#md-editor-preview-wrapper
   */
  scrollElement: {
    type: [String, Object],
    default: void 0
  },
  theme: {
    type: String,
    default: "light"
  },
  /**
   * 高亮标题相对滚动容器顶部偏移量，即距离该值时，高亮当前目录菜单项
   *
   * 默认：20px
   */
  offsetTop: {
    type: Number,
    default: 20
  },
  /**
   * 滚动区域的固定顶部高度
   *
   * 默认：0
   */
  scrollElementOffsetTop: {
    type: Number,
    default: 0
  },
  onClick: {
    type: Function,
    default: void 0
  },
  onActive: {
    type: Function,
    default: void 0
  },
  /**
   * 滚动容器是否在web component中，默认不在
   *
   * 在其中的话通过document查询不到
   */
  isScrollElementInShadow: {
    type: Boolean,
    default: !1
  },
  /**
   * 设置与哪个区域同步，默认与内容区域同步
   *
   * >= v5.3.0
   */
  syncWith: {
    type: String,
    default: "preview"
  },
  /**
   * 控制最大显示的目录层级
   */
  catalogMaxDepth: {
    type: Number,
    default: void 0
  }
}, W = /* @__PURE__ */ z({
  name: "MdCatalog",
  props: re,
  emits: ["onClick", "onActive"],
  setup(e, l) {
    const C = e.editorId, n = `#${C}-preview-wrapper`, E = X({
      list: [],
      show: !1,
      scrollElement: e.scrollElement || n
    }), m = G(), b = $(), f = $(), s = $(), r = $(), L = G(), R = $({});
    V("scrollElementRef", f), V("roorNodeRef", r);
    const x = Y(() => {
      const t = [];
      return E.list.forEach((o, a) => {
        if (e.catalogMaxDepth && o.level > e.catalogMaxDepth)
          return;
        const {
          text: u,
          level: p,
          line: d
        } = o, i = {
          level: p,
          text: u,
          line: d,
          index: a + 1,
          active: m.value === o
        };
        if (t.length === 0)
          t.push(i);
        else {
          let k = t[t.length - 1];
          if (i.level > k.level)
            for (let h = k.level + 1; h <= 6; h++) {
              const {
                children: v
              } = k;
              if (!v) {
                k.children = [i];
                break;
              }
              if (k = v[v.length - 1], i.level <= k.level) {
                v.push(i);
                break;
              }
            }
          else
            t.push(i);
        }
      }), t;
    }), B = () => {
      if (E.scrollElement instanceof HTMLElement)
        return E.scrollElement;
      let t = document;
      return (E.scrollElement === n || e.isScrollElementInShadow) && (t = b.value?.getRootNode()), t.querySelector(E.scrollElement);
    }, _ = (t) => {
      if (t.length === 0)
        return m.value = void 0, E.list = [], !1;
      const {
        activeHead: o,
        activeIndex: a
      } = t.reduce((d, i, k) => {
        let h = 0;
        if (e.syncWith === "preview") {
          const v = r.value?.getElementById(e.mdHeadingId({
            text: i.text,
            level: i.level,
            index: k + 1,
            currentToken: i.currentToken,
            nextToken: i.nextToken
          }));
          v instanceof HTMLElement && (h = oe(v, f.value));
        } else {
          const v = L.value;
          if (v) {
            const S = v.lineBlockAt(v.state.doc.line(i.line + 1).from).top, y = v.scrollDOM.scrollTop;
            h = S - y;
          }
        }
        return h < e.offsetTop && h > d.minTop ? {
          activeHead: i,
          activeIndex: k,
          minTop: h
        } : d;
      }, {
        activeHead: t[0],
        activeIndex: 0,
        minTop: Number.MIN_SAFE_INTEGER
      });
      let u = o;
      const {
        catalogMaxDepth: p
      } = e;
      if (p && u.level > p) {
        for (let d = a; d >= 0; d--) {
          const i = t[d];
          if (i.level <= p) {
            u = i;
            break;
          }
        }
        if (u.level > p) {
          const d = t.find((i) => i.level <= p);
          d && (u = d);
        }
      }
      m.value = u, E.list = t;
    }, F = (t, o) => {
      R.value.top = o.offsetTop + D(o, "padding-top") + "px", e.onActive?.(t, o), l.emit("onActive", t, o);
    }, M = () => {
      _(E.list);
    }, c = (t) => {
      if (s.value?.removeEventListener("scroll", M), e.syncWith === "editor")
        s.value = L.value?.scrollDOM;
      else {
        const o = B();
        f.value = o, s.value = o === document.documentElement ? document : o;
      }
      _(t), s.value?.addEventListener("scroll", M);
    }, g = (t) => {
      L.value = t;
    };
    J([() => e.syncWith, L, () => e.catalogMaxDepth], () => {
      c(E.list);
    }), K(() => {
      r.value = b.value.getRootNode(), w.on(C, {
        name: j,
        callback: c
      }), w.on(C, {
        name: U,
        callback: g
      }), w.emit(C, te), w.emit(C, le);
    }), Z(() => {
      w.remove(C, j, c), w.remove(C, U, g), s.value?.removeEventListener("scroll", M);
    });
    const H = (t, o) => {
      e.onClick?.(t, o), l.emit("onClick", t, o);
    };
    return () => N("div", {
      class: [`${O}-catalog`, e.theme === "dark" && `${O}-catalog-dark`, e.class || ""],
      ref: b
    }, [x.value.length > 0 && N(ee, null, [N("div", {
      class: `${O}-catalog-indicator`,
      style: R.value
    }, null), N("div", {
      class: `${O}-catalog-container`
    }, [x.value.map((t) => N(Q, {
      mdHeadingId: e.mdHeadingId,
      tocItem: t,
      key: `link-${t.level}-${t.text}`,
      onActive: F,
      onClick: H,
      scrollElementOffsetTop: e.scrollElementOffsetTop
    }, null))])])]);
  }
});
W.install = (e) => (e.component(W.name, W), e);
export {
  W as M,
  ve as a,
  ge as s
};
